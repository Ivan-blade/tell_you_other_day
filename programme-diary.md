+ 2020-2-16
    + 创建vue3.x项目
        + vue create tell-you-other-day
    + 引入vuetify
        + vue add vuetify(如果无法启动npm install )
        + 允许window下开发
            + 在eslintrc中的rule下增加"linebreak-style": [0 ,"error", "windows"],
    + 单位转换移动端适应rem单位（这个先不管，好像vuetify是自适应组件库，初步看来不需要单位转换）
        + npm install lib-flexible
        + main.js中引入
        + 根目录下创建postcss.config.js进行px转rem的基准配置通常为75

+ 2020-2-17
    + 引入google图标库（内网访问不了谷歌，需要下载到本地库--注意不是google官方的，不一定会及时更新）
        + npm install material-design-icons-iconfont -D
        + main.js中import 'material-design-icons-iconfont/dist/material-design-icons.css'
    + 引入bar组件
        + 创建相关组件--Navbar
        + 在app中引入
    + 开始思考具体结构和功能实现

+ 2020-2-18
    + 开始编写各个功能模块以及对应前端路由

+ 2020-2-19
    + 看date pickers的文档
    + 文档中是说当day/mouth/year发生改变时都会发生change事件，可是只说了监测pickerDate参数可以了解月和年的变化，但是怎么监测天的变化呢？机智的我直接监测了v-model绑定获取当前日期的参数用于检测天的变化
    + 下面的思路
        + 本来的思路是点击日期直接相应编辑事件，但是添加click事件之后打印日志都做不到，一开始以为是没有找到该组件下点击事件的正确姿势，后来想想，这个组件默认点击之后就会响应一个事件，所以应该不会允许自定义点击事件，于是只能通过检测变化，响应其他页面，再进行点击事件的设置
        + 通过监测目前的响应日期，响应一个模板页面，向模板中传递当前选中日期，点击该模板可以进入编辑页面，该页面存在两个tab，一个是日记模块，一个是悄悄话板块，还存在一个用户视图切换功能，如果匹配了其他id的用户可以切换到该用户的日记模块，当然悄悄话模块要达到一定的条件才会开放浏览权限
        + 后期的处理
            + 文章存储进数据库中分为两张表，一张表用于记录文章大体信息，id，编写者，创建日期，文章类别（日记还是悄悄话）等等，另一张表用于保存文章的id和具体内容（两个id应该会有所区别，可能需要第三个参数来连接两张数据表）
            + 在打开软件时，向数据库查询该用户所有文章的创建日期字段，形成一个数组，传入datepickers组件，标记好存在编辑行为的日期，当点击某个日期时，响应一个组件，点击该组件，前端将会根据目前的日期去数据库中查询该用户对应时间的文章，存在则渲染，不存在则返回空

    + 看一下github上面一个博客项目，了解一下文档的输入和存储吧

+ 2020-2-20
    + 看样子文章编辑会用到mavon-editor插件，不过这是通常在博客中使用的markdown编辑器，在移动端效果会怎么样就不得而知了，官方好像没有移动端的方案，在看看quil吧???
    + 还没看quil，直接打算用mavon了，官方网址：https://github.com/hinesboy/mavonEditor，工具栏和预览关闭看起来舒服多了，看一下预览功能？？？
    + 发现个bug，明明是引入的组件但是在打开navbar时mavon会在navbar上层，调整z-index无效，这个用的时候可能需要嵌入到编辑页面中，，一般编辑页面处于关闭状态，打开之后编辑完成之前也不会打开navbar，不过为什么会在navbar上层呢？？？
    + 效率比较低，麻烦

+ 2020-2-21
    + 装好了springboot的环境，core中以后会引入security，下一阶段主要在web中进行开发
    + 数据库构建
        + user
            ```
                CREATE TABLE IF NOT EXISTS `user` (
                `id` bigint(32) NOT NULL AUTO_INCREMENT,
                `username` varchar(255) DEFAULT NULL,
                `password` varchar(255) DEFAULT NULL,
                `userphone` bigint(32) DEFAULT NULL,
                `email` varchar(64) DEFAULT NULL,
                `enabled` tinyint(1) NOT NULL DEFAULT 1,
                PRIMARY KEY (`id`)
                ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
            ```
        + 这边看了一下id，主要是感觉单纯的自增id有点简陋，百度发现了uuid的概念
            + 自增id
                + 优点
                    + 性能较高
                    + 占用空间小
                + 缺点
                    + 数据量达到一定程度将会超出自增长取值范围
                    + 由于不同表之间的id都是从1开始大量重复结果就是不同的表数据合并比较麻烦，所以不适合分布式场景，尤其是合并表的场景
                    + 由于是自增的所以可能被猜出业务量，缺乏安全性
            + uuid
                + 优点
                    + uuid的生成随MAC地址、时间戳、名字空间（Namespace）、随机或伪随机数、时序等元素的变化而变化，假设时间戳的最小精度为秒，随机数为个位，也需要在一秒内出现多个注册用户才会重复，重复概率极低，每个uuid都可能是世界唯一的，所以在合并表时比较简单，适合分布式场景
                    + UUID是16字节128位长的数字，通常以36字节的字符串表示，所以可表示范围也较大，比起自增id不容易溢出
                + 缺点
                    + 性能不那么高
                    + 相对占用存储空间较多
                    + 无序（虽然根据时间生成但是结果并不会存在序列关系），不利于查询
            + snowflake处于两者之间的方法，两者优缺点的平衡吧
                + 优点
                    + 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
                    + 不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的。（等等，这是不是意味着要单独部署这个服务，有点麻烦）
                    + 可以根据自身业务特性分配bit位，非常灵活
                + 缺点（新的缺点已经出现？？？）
                    + 十分依赖机器时钟，如果时钟出问题，id也会出问题，比如服务器重启，机器时钟没有及时更新（多半是在固定的某一年）
            + 综上还是老实自增id吧，写个日记还用不上分布式（主要是现在还不会）

        + 写一下登录页面和登录逻辑